---
title: "Probability Distributions in PEcAn"
output: html_document
---

# Defining probability distribution on parameters
We consider an example whereby prior distributions are placed on ecological
parameters. The distribution information is stored in a list with one 
element per multivariate parameter. For example, one can consider an 
unknown covariance matrix as a single multivariate parameter. Another 
example is a subset of parameters that must some to one; it makes sense to 
consider this subset a single multivariate parameter. Each list element is 
itself a list, with elements:
- `param_name`: the name of the multivariate parameter.
- `dist_name`: the name of the probability distribution assigned to the multivariate parameter.
- `dist_params`: list of parameters defining the probability distribution.
- `length`: the total number of scalars making up the multivariate parameter.
- `constraint`: constraint on the support of the parameter. Currently accepts
                bound constraints by passing a vector of length 2, or the string
                "simplex" for a sum-to-one constraint.
- `scalar_names`: optional, the names of the individual scalars composing the 
multivariate parameter. In the case of a scalar parameter, this is not used.
If not provided in the multivariate case, defaults values are set.

```{r}
base_dir <- file.path("/projectnb", "dietzelab", "arober", "gp-calibration")
src_dir <- file.path(base_dir, "src")

pecan_base_dir <- file.path("/projectnb", "dietzelab", "arober", "sipnet_calibration")
pecan_src_dir <- file.path(pecan_base_dir, "src")

source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(pecan_src_dir, "prob_dists.r"))
```


# Defining prior distribution information.
```{r}
prior_list <- list()

# Dirichlet prior on parameters with sum-to-one constraint.
prior_list$alloc_pars <- list(
  param_name = "alloc_pars",
  dist_name = "Dirichlet",
  constraint = "simplex",
  length = 4L,
  scalar_names = c("root_allocation_fraction", "wood_allocation_fraction",
                   "leaf_allocation_fraction", "coarse_root_allocation_fraction"),
  dist_params = list(alpha=c(0.1, 0.5, 0.2, 0.2))
)

# Beta prior on root turnover rate.
prior_list$root_turnover_rate <- list(
  param_name = "root_turnover_rate",
  dist_name = "Beta",
  constraint = c(0,1),
  length = 1L,
  dist_params = list(shape1=2, shape2=4)
)

# Gamma prior on Amax.
prior_list$Amax <- list(
  param_name = "Amax",
  dist_name = "Gamma",
  constraint = c(0, Inf),
  length = 1L,
  dist_params = list(shape=224, rate=2)
)
```


```{r}
# Multivariate parameter names.
get_param_names(prior_list, flatten=FALSE)
```

```{r}
# Scalar parameter names.
get_param_names(prior_list, flatten=TRUE)
```


# Drawing Samples
```{r}
# Get sampling function.
rprior <- get_sampling_func(prior_list)
```

```{r}
# Draw independent samples.
samp <- rprior(10)
print(samp)
```

# Evaluating log-density
```{r}
# Get log density function.
lprior <- get_log_density_func(prior_list)
```

```{r}
# Evaluate log-density at sampled points.
lprior(samp)
```

```{r}
# Evaluations outside of prior support return -Inf.
test_par_outside_supp <- samp
test_par_outside_supp[2,"root_allocation_fraction"] <- 100 # Violates sum-to-one constraint.
test_par_outside_supp[4,"root_turnover_rate"] <- 2 # Violates (0,1) bounds.
test_par_outside_supp[5,"Amax"] <- -1 # Violates nonnegativity.

lprior(test_par_outside_supp)
```

# Parameter Transformations

```{r}
# Get forward and inverse default parameter transformations.
par_maps <- get_par_map_funcs(prior_list)
```


The transformed parameters are given names in a standardized format, which are 
based on the parameter names in `prior_list` (note: not the scalar names). 
The dimension of the transformed parameters may slightly differ from the 
dimension of original parameters; currently the only way this can happen is 
for simplex-valued parameters. Parameters lying on the d-simplex can be 
represented with only d-1 values, so the transformed parameter has dimension 
one lower than the original.

```{r}
# Transform to unconstrained space.
phi <- par_maps$fwd(samp)
print(phi)
```

The inverse map also has attribute `log_det_J` which is a vector of the log of 
the Jacobian determinant factor that appears in the change-of-variables 
formula (the vector has one element per input). This is used in computing the 
density of the transformed variables.
```{r}
# Transform back.
par <- par_maps$inv(phi)
print(par)
```

```{r}
# Other than the log_det_J attribute, should map back to the original parameters.
print(paste0("Param order maintained: ", all(colnames(par)==colnames(samp))))
print(paste0("Inverse mapped back to same parameter values: ", 
             all.equal(par, samp, check.attributes=FALSE)))
```





